#include "neurones.hpp"

using namespace std;



bool Neurone :: update(double step, double h, double poisson) /*! This function will retrun true if the neuron is spiking.*/

{	
		buffer = update_buffer(); /*! Updates buffer */
		if (V > V_thr) { /*! If the neurone is spiking: the amount of total spikes will increase, the tim at which the spike occured will be saved and the membrane potential will become 0. */
			++spikes;
			spk_time.push_back(step*h-h);
			V = 0;
			return true;
		}
		if (!spk_time.empty() and ((step-spk_time.back()/h) < r_per and !(V > V_thr))){ /*! If the neuron is refractory but not spiking : the membrane potential becomes 0 */
		
			V = 0;
			return false;
		}

	
		else { /*! If the neuron is neither spiking or refractory: V will be increased by the value in the buffer (membrane potential coming from local neighboring neurons) and by the noise coming from external neurons. The noise is generated by 1000 excitatory neurons. To calculate it, we use the poisson distribution. */
			
			//V = C*V+ I*(1-C)*R + poisson + buffer[fmod (step, D+1)];
			V = C*V+ I*(1-C)*R + poisson + buffer[buffer.size()-1];
		
			return false;
		}
	
		
}

	
vector <double> Neurone::add_to_buffer (/*int step,*/ double J) /*! The first value in buffer will receive J, this is used for targets to receive J */
{
	//buffer[fmod (step+D, D+1)] += J;
	
	buffer[0] += J;
	
	return buffer;
	
}



double Neurone :: getPotential() const /*! Allows acces to potential */
{
	return V;
}

void Neurone::setPotential(double v) { /*! Allows modification of potential  */
	
	V = v;
	}


vector <double> Neurone::update_buffer(){ /*! Every time a value J (or -g*J) is received from another neuron, it goes into buffer[0]. Before every update, the buffer inputs will shift towards the end of the vector, so the last element will be deleted and the first value will be 0.*/
	
		
		for (size_t i(0); i < buffer.size(); ++i){ 
				
			buffer[buffer.size()-i] = buffer[buffer.size()-i-1];
		} 
	
		buffer[0] = 0;       
		
		return buffer;
	
}


void Neurone::addTarget (int target) { /*! Adds a target, which is a neuron that our neuron is connected to, so that it will receive J from our neuron */
	
	targets.push_back(target);
}
	
vector <int> Neurone::getTargets () const { /*! A target is a neuron that receives a membrane potential from the neuron in question through a connection. This method allows acces to the target */
	
	return targets;
}

void Neurone::set_i_ext(double i) { /*! Allows modification of external input. This function is particularly useful for testing the program with different inputs. */
		I = i;
}
double Neurone::getSpikes() const { /*! allows access to spikes */
	
	return spikes;
	}
	
vector <double> Neurone::get_spk_time() const { /*! Allows acces to spike times */
	
	return spk_time;
	}
Neurone :: Neurone() /*! Constructor */
:spikes(0), V(0), buffer(vector<double> (D))
{}
Neurone:: ~Neurone() {} /*! Destructor */
